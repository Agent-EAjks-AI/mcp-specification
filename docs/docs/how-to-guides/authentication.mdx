# Add Authentication to Your MCP Server

Secure your MCP server with proper authentication mechanisms. This guide covers multiple authentication methods from simple API keys to enterprise-grade OAuth 2.0.

## Overview

Authentication in MCP servers typically involves:
1. **Transport-level security** (TLS, secure channels)  
2. **Application-level authentication** (API keys, tokens)
3. **Authorization** (permissions, role-based access)

## API Key Authentication

The simplest and most common authentication method for MCP servers.

### Implementation

```python
import hashlib
import secrets
from typing import Optional

class APIKeyAuth:
    def __init__(self):
        # In production, store these in a secure database
        self.api_keys = {
            "ak_live_1234567890abcdef": {
                "user_id": "user_1",
                "permissions": ["tools:execute", "resources:read"],
                "rate_limit": 1000,  # requests per hour
                "created_at": "2024-01-01T00:00:00Z"
            }
        }
    
    def generate_api_key(self, prefix: str = "ak_live") -> str:
        """Generate a new API key."""
        random_part = secrets.token_hex(16)
        return f"{prefix}_{random_part}"
    
    def validate_api_key(self, api_key: str) -> Optional[dict]:
        """Validate API key and return user info."""
        return self.api_keys.get(api_key)
    
    def hash_api_key(self, api_key: str) -> str:
        """Hash API key for secure storage."""
        return hashlib.sha256(api_key.encode()).hexdigest()

# Integrate with MCP server
@server.middleware
async def authenticate_request(request, handler):
    """Authentication middleware for MCP server."""
    # Extract API key from headers or query params
    api_key = None
    
    if hasattr(request, 'headers'):
        # HTTP transport
        auth_header = request.headers.get('Authorization', '')
        if auth_header.startswith('Bearer '):
            api_key = auth_header[7:]
    elif hasattr(request, 'params'):
        # Check request params for API key
        api_key = request.params.get('api_key')
    
    if not api_key:
        raise MCPError("Authentication required", code="auth_required")
    
    # Validate API key
    auth = APIKeyAuth()
    user_info = auth.validate_api_key(api_key)
    
    if not user_info:
        raise MCPError("Invalid API key", code="auth_invalid")
    
    # Add user info to request context
    request.user = user_info
    
    return await handler(request)

@server.call_tool()
async def call_tool(name: str, arguments: dict, request):
    """Tool execution with authentication."""
    # Check if user has permission
    if "tools:execute" not in request.user["permissions"]:
        raise MCPError("Insufficient permissions", code="auth_insufficient")
    
    # Execute tool
    return await execute_tool(name, arguments)
```

### Client Configuration

```json
{
  "mcpServers": {
    "authenticated-server": {
      "command": "python",
      "args": ["server.py"],
      "env": {
        "API_KEY": "ak_live_1234567890abcdef"
      }
    }
  }
}
```

## JWT Token Authentication

More sophisticated authentication using JSON Web Tokens.

### Implementation

```python
import jwt
from datetime import datetime, timedelta
from typing import Optional

class JWTAuth:
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.algorithm = "HS256"
    
    def create_token(self, user_id: str, permissions: list, expires_in_hours: int = 24) -> str:
        """Create a new JWT token."""
        payload = {
            "user_id": user_id,
            "permissions": permissions,
            "iat": datetime.utcnow(),
            "exp": datetime.utcnow() + timedelta(hours=expires_in_hours)
        }
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def validate_token(self, token: str) -> Optional[dict]:
        """Validate JWT token and return payload."""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise MCPError("Token expired", code="auth_expired")
        except jwt.InvalidTokenError:
            raise MCPError("Invalid token", code="auth_invalid")

# Middleware integration
@server.middleware
async def jwt_auth_middleware(request, handler):
    """JWT authentication middleware."""
    # Extract token from Authorization header
    auth_header = getattr(request, 'headers', {}).get('Authorization', '')
    
    if not auth_header.startswith('Bearer '):
        raise MCPError("Bearer token required", code="auth_required")
    
    token = auth_header[7:]
    
    # Validate token
    jwt_auth = JWTAuth(os.getenv('JWT_SECRET_KEY'))
    payload = jwt_auth.validate_token(token)
    
    # Add user info to request
    request.user = payload
    
    return await handler(request)
```

## OAuth 2.0 Integration

Enterprise-grade authentication using OAuth 2.0.

### Server Implementation

```python
import aiohttp
from urllib.parse import urlencode

class OAuth2Auth:
    def __init__(self, client_id: str, client_secret: str, auth_server_url: str):
        self.client_id = client_id
        self.client_secret = client_secret
        self.auth_server_url = auth_server_url
        self.token_cache = {}
    
    async def validate_access_token(self, access_token: str) -> Optional[dict]:
        """Validate access token with OAuth provider."""
        cache_key = f"token:{access_token}"
        
        # Check cache first
        if cache_key in self.token_cache:
            cached_data, expires_at = self.token_cache[cache_key]
            if datetime.utcnow() < expires_at:
                return cached_data
        
        # Validate with auth server
        async with aiohttp.ClientSession() as session:
            async with session.get(
                f"{self.auth_server_url}/userinfo",
                headers={"Authorization": f"Bearer {access_token}"}
            ) as response:
                if response.status == 200:
                    user_info = await response.json()
                    
                    # Cache for 5 minutes
                    expires_at = datetime.utcnow() + timedelta(minutes=5)
                    self.token_cache[cache_key] = (user_info, expires_at)
                    
                    return user_info
                elif response.status == 401:
                    raise MCPError("Invalid access token", code="auth_invalid")
                else:
                    raise MCPError("Authentication service unavailable", code="auth_service_error")

@server.middleware
async def oauth2_middleware(request, handler):
    """OAuth 2.0 authentication middleware."""
    auth_header = getattr(request, 'headers', {}).get('Authorization', '')
    
    if not auth_header.startswith('Bearer '):
        raise MCPError("OAuth access token required", code="auth_required")
    
    access_token = auth_header[7:]
    
    oauth_auth = OAuth2Auth(
        client_id=os.getenv('OAUTH_CLIENT_ID'),
        client_secret=os.getenv('OAUTH_CLIENT_SECRET'),
        auth_server_url=os.getenv('OAUTH_SERVER_URL')
    )
    
    user_info = await oauth_auth.validate_access_token(access_token)
    request.user = user_info
    
    return await handler(request)
```

### Client OAuth Flow

```python
import asyncio
import webbrowser
from urllib.parse import urlencode, parse_qs
from aiohttp import web

class OAuth2Client:
    def __init__(self, client_id: str, auth_url: str, redirect_uri: str = "http://localhost:8080/callback"):
        self.client_id = client_id
        self.auth_url = auth_url
        self.redirect_uri = redirect_uri
        self.access_token = None
    
    async def authenticate(self) -> str:
        """Perform OAuth 2.0 authentication flow."""
        # Start local server for callback
        app = web.Application()
        app.router.add_get('/callback', self.handle_callback)
        
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, 'localhost', 8080)
        await site.start()
        
        # Build authorization URL
        auth_params = {
            'response_type': 'code',
            'client_id': self.client_id,
            'redirect_uri': self.redirect_uri,
            'scope': 'mcp:access',
            'state': 'random_state_value'
        }
        
        auth_url = f"{self.auth_url}?{urlencode(auth_params)}"
        
        # Open browser for user authentication
        webbrowser.open(auth_url)
        
        # Wait for callback
        while not self.access_token:
            await asyncio.sleep(0.1)
        
        await runner.cleanup()
        return self.access_token
    
    async def handle_callback(self, request):
        """Handle OAuth callback."""
        code = request.query.get('code')
        if code:
            # Exchange code for access token
            self.access_token = await self.exchange_code_for_token(code)
        
        return web.Response(text="Authentication complete! You can close this window.")
```

## Role-Based Access Control (RBAC)

Implement fine-grained permissions with roles and permissions.

### Implementation

```python
from enum import Enum
from typing import Set

class Permission(Enum):
    TOOLS_EXECUTE = "tools:execute"
    TOOLS_LIST = "tools:list"
    RESOURCES_READ = "resources:read"
    RESOURCES_WRITE = "resources:write"
    PROMPTS_ACCESS = "prompts:access"
    ADMIN_ACCESS = "admin:access"

class Role:
    def __init__(self, name: str, permissions: Set[Permission]):
        self.name = name
        self.permissions = permissions

class RBACAuth:
    def __init__(self):
        # Define roles
        self.roles = {
            "viewer": Role("viewer", {
                Permission.TOOLS_LIST,
                Permission.RESOURCES_READ,
                Permission.PROMPTS_ACCESS
            }),
            "user": Role("user", {
                Permission.TOOLS_EXECUTE,
                Permission.TOOLS_LIST,
                Permission.RESOURCES_READ,
                Permission.PROMPTS_ACCESS
            }),
            "admin": Role("admin", {
                Permission.TOOLS_EXECUTE,
                Permission.TOOLS_LIST,
                Permission.RESOURCES_READ,
                Permission.RESOURCES_WRITE,
                Permission.PROMPTS_ACCESS,
                Permission.ADMIN_ACCESS
            })
        }
        
        # User role assignments
        self.user_roles = {
            "user_1": ["user"],
            "user_2": ["viewer"],
            "user_3": ["admin"]
        }
    
    def check_permission(self, user_id: str, required_permission: Permission) -> bool:
        """Check if user has required permission."""
        user_roles = self.user_roles.get(user_id, [])
        
        for role_name in user_roles:
            role = self.roles.get(role_name)
            if role and required_permission in role.permissions:
                return True
        
        return False
    
    def get_user_permissions(self, user_id: str) -> Set[Permission]:
        """Get all permissions for a user."""
        permissions = set()
        user_roles = self.user_roles.get(user_id, [])
        
        for role_name in user_roles:
            role = self.roles.get(role_name)
            if role:
                permissions.update(role.permissions)
        
        return permissions

# Authorization decorator
def require_permission(permission: Permission):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            request = kwargs.get('request') or args[-1]  # Assume request is last arg
            
            if not hasattr(request, 'user'):
                raise MCPError("Authentication required", code="auth_required")
            
            rbac = RBACAuth()
            user_id = request.user.get('user_id')
            
            if not rbac.check_permission(user_id, permission):
                raise MCPError("Insufficient permissions", code="auth_insufficient")
            
            return await func(*args, **kwargs)
        
        return wrapper
    return decorator

# Usage in server
@server.call_tool()
@require_permission(Permission.TOOLS_EXECUTE)
async def call_tool(name: str, arguments: dict, request):
    """Tool execution with RBAC."""
    return await execute_tool(name, arguments)

@server.read_resource()
@require_permission(Permission.RESOURCES_READ)
async def read_resource(uri: str, request):
    """Resource access with RBAC."""
    return await get_resource(uri)
```

## Environment Configuration

Secure configuration management for authentication.

### Environment Variables

```bash
# .env file
JWT_SECRET_KEY=your-super-secret-jwt-key-here
API_KEY_SALT=random-salt-for-api-key-hashing
OAUTH_CLIENT_ID=your-oauth-client-id
OAUTH_CLIENT_SECRET=your-oauth-client-secret
OAUTH_SERVER_URL=https://auth.example.com
DB_CONNECTION_STRING=postgresql://user:pass@localhost/auth_db
REDIS_URL=redis://localhost:6379/0
```

### Configuration Class

```python
import os
from typing import Optional

class AuthConfig:
    def __init__(self):
        self.jwt_secret = self.get_required_env('JWT_SECRET_KEY')
        self.api_key_salt = self.get_required_env('API_KEY_SALT')
        self.oauth_client_id = os.getenv('OAUTH_CLIENT_ID')
        self.oauth_client_secret = os.getenv('OAUTH_CLIENT_SECRET')
        self.oauth_server_url = os.getenv('OAUTH_SERVER_URL')
        self.db_connection = os.getenv('DB_CONNECTION_STRING')
        self.redis_url = os.getenv('REDIS_URL')
    
    def get_required_env(self, key: str) -> str:
        """Get required environment variable or raise error."""
        value = os.getenv(key)
        if not value:
            raise ValueError(f"Required environment variable {key} not set")
        return value
    
    def validate_oauth_config(self) -> bool:
        """Check if OAuth configuration is complete."""
        return all([
            self.oauth_client_id,
            self.oauth_client_secret,
            self.oauth_server_url
        ])
```

## Testing Authentication

### Unit Tests

```python
import pytest
from unittest.mock import AsyncMock, patch

class TestAuthentication:
    @pytest.fixture
    def auth_server(self):
        server = MCPServer("test-server")
        auth = APIKeyAuth()
        server.auth = auth
        return server
    
    async def test_valid_api_key(self, auth_server):
        """Test authentication with valid API key."""
        # Mock request with valid API key
        request = MockRequest(headers={'Authorization': 'Bearer ak_live_1234567890abcdef'})
        
        # Should not raise exception
        result = await auth_server.authenticate_request(request, lambda r: "success")
        assert result == "success"
        assert hasattr(request, 'user')
    
    async def test_invalid_api_key(self, auth_server):
        """Test authentication with invalid API key."""
        request = MockRequest(headers={'Authorization': 'Bearer invalid_key'})
        
        with pytest.raises(MCPError) as exc_info:
            await auth_server.authenticate_request(request, lambda r: "success")
        
        assert exc_info.value.code == "auth_invalid"
    
    async def test_missing_api_key(self, auth_server):
        """Test authentication without API key."""
        request = MockRequest(headers={})
        
        with pytest.raises(MCPError) as exc_info:
            await auth_server.authenticate_request(request, lambda r: "success")
        
        assert exc_info.value.code == "auth_required"
```

### Integration Tests

```python
async def test_authenticated_tool_execution():
    """Test full authentication flow with tool execution."""
    # Start authenticated server
    server = AuthenticatedWeatherServer()
    transport = TestTransport()
    
    # Connect client with authentication
    client = MCPClient()
    client.set_auth_header('Bearer', 'ak_live_1234567890abcdef')
    await client.connect(transport)
    
    # Test tool execution
    result = await client.call_tool("get_weather", {"city": "London"})
    assert "temperature" in result
    
    # Test with invalid auth
    client.set_auth_header('Bearer', 'invalid_key')
    
    with pytest.raises(MCPError) as exc_info:
        await client.call_tool("get_weather", {"city": "London"})
    
    assert exc_info.value.code == "auth_invalid"
```

## Best Practices

### 1. **Security**
- Use environment variables for secrets
- Implement proper token expiration
- Hash API keys before storage
- Use HTTPS for all communications

### 2. **Performance**
- Cache authentication results appropriately
- Use connection pooling for auth services
- Implement efficient token validation

### 3. **User Experience**
- Provide clear authentication error messages
- Implement token refresh mechanisms
- Offer multiple authentication methods

### 4. **Monitoring**
- Log authentication attempts
- Monitor for brute force attacks
- Track token usage patterns

### 5. **Maintenance**
- Regularly rotate secrets
- Update dependencies for security patches
- Review and audit authentication logs

## Troubleshooting

### Common Issues

**Authentication fails with valid credentials:**
- Check token expiration
- Verify environment variables are set
- Ensure proper header format

**Performance issues with authentication:**
- Implement caching for token validation
- Use connection pooling for external auth services
- Consider async authentication flows

**OAuth flow issues:**
- Verify redirect URI configuration
- Check client ID and secret
- Ensure proper scope permissions

## Next Steps

After implementing authentication:
- Add [monitoring and logging](/docs/how-to-guides/monitoring)
- Implement [rate limiting](/docs/how-to-guides/security)
- Deploy securely using [deployment guide](/docs/how-to-guides/deployment)