# Core Client Concepts

Understanding MCP client concepts is essential for integrating MCP capabilities into AI applications and other systems. This guide covers the fundamental concepts, patterns, and best practices for MCP client development.

## Client Responsibilities

MCP clients serve as the orchestration layer that:

- **Manages connections** to multiple MCP servers
- **Discovers and negotiates** server capabilities
- **Executes tools** and processes results
- **Accesses resources** and manages content
- **Handles user interactions** and presents information
- **Maintains security** and permission boundaries

## Client Lifecycle

### 1. Initialization

```python
# Example client initialization
client = MCPClient("my-ai-assistant")
await client.initialize({
    "client_info": {
        "name": "my-ai-assistant",
        "version": "1.0.0"
    },
    "capabilities": {
        "sampling": {},
        "roots": {"listChanged": True}
    }
})
```

### 2. Server Connection

```python
# Connect to multiple servers
servers = [
    {"name": "filesystem", "transport": "stdio", "command": ["python", "fs_server.py"]},
    {"name": "weather", "transport": "https", "url": "https://weather.example.com/mcp"},
    {"name": "database", "transport": "stdio", "command": ["node", "db_server.js"]}
]

for server_config in servers:
    server = await client.connect_server(server_config)
    await client.initialize_server(server)
```

### 3. Capability Discovery

```python
# Discover what each server can do
for server in client.servers:
    tools = await server.list_tools()
    resources = await server.list_resources()
    prompts = await server.list_prompts()
    
    print(f"Server {server.name}:")
    print(f"  Tools: {[t.name for t in tools]}")
    print(f"  Resources: {[r.uri for r in resources]}")
    print(f"  Prompts: {[p.name for p in prompts]}")
```

## Core Client Operations

### Tool Execution

Tools are the primary way clients interact with server capabilities:

```python
async def execute_tool(client, server_name: str, tool_name: str, arguments: dict):
    """Execute a tool on a specific server."""
    server = client.get_server(server_name)
    
    try:
        result = await server.call_tool(tool_name, arguments)
        return result.content
    except MCPError as e:
        print(f"Tool execution failed: {e}")
        return None

# Example usage
weather_result = await execute_tool(
    client, 
    "weather", 
    "get_weather", 
    {"city": "San Francisco", "units": "metric"}
)
```

### Resource Access

Resources provide access to data and content:

```python
async def read_resource(client, server_name: str, resource_uri: str):
    """Read a resource from a server."""
    server = client.get_server(server_name)
    
    try:
        resource = await server.read_resource(resource_uri)
        return resource.contents
    except MCPError as e:
        print(f"Resource access failed: {e}")
        return None

# Example usage
file_content = await read_resource(
    client,
    "filesystem",
    "file:///home/user/document.txt"
)
```

### Prompt Management

Prompts provide templates for common interactions:

```python
async def get_prompt(client, server_name: str, prompt_name: str, arguments: dict = None):
    """Get a prompt template from a server."""
    server = client.get_server(server_name)
    
    try:
        prompt = await server.get_prompt(prompt_name, arguments or {})
        return prompt.messages
    except MCPError as e:
        print(f"Prompt retrieval failed: {e}")
        return None

# Example usage
code_review_prompt = await get_prompt(
    client,
    "development",
    "code_review",
    {"language": "python", "file_path": "src/main.py"}
)
```

## Advanced Client Patterns

### Server Orchestration

Coordinate multiple servers to accomplish complex tasks:

```python
async def orchestrated_workflow(client, user_query: str):
    """Example of orchestrating multiple servers."""
    
    # 1. Parse user intent
    intent_result = await execute_tool(
        client, "nlp", "parse_intent", {"query": user_query}
    )
    
    # 2. Based on intent, gather information
    if intent_result.intent == "weather_and_calendar":
        # Get weather information
        weather_task = execute_tool(
            client, "weather", "get_weather", 
            {"city": intent_result.location}
        )
        
        # Get calendar events
        calendar_task = execute_tool(
            client, "calendar", "list_events", 
            {"date": intent_result.date}
        )
        
        # Execute in parallel
        weather_result, calendar_result = await asyncio.gather(
            weather_task, calendar_task
        )
        
        return {
            "weather": weather_result,
            "calendar": calendar_result
        }
```

### Sampling Integration

Handle server-initiated sampling requests:

```python
class SamplingHandler:
    def __init__(self, llm_client):
        self.llm_client = llm_client
    
    async def handle_sampling_request(self, request):
        """Handle sampling request from MCP server."""
        messages = request.params.messages
        max_tokens = request.params.max_tokens
        
        # Send to LLM
        response = await self.llm_client.create_completion(
            messages=messages,
            max_tokens=max_tokens,
            temperature=request.params.temperature or 0.7
        )
        
        return {
            "role": "assistant",
            "content": response.content
        }

# Register sampling handler
client.set_sampling_handler(SamplingHandler(llm_client))
```

### Error Handling and Recovery

Implement robust error handling:

```python
class RobustClient:
    def __init__(self):
        self.client = MCPClient("robust-client")
        self.retry_config = {
            "max_retries": 3,
            "backoff_factor": 1.5,
            "timeout": 30
        }
    
    async def call_tool_with_retry(self, server_name: str, tool_name: str, arguments: dict):
        """Call tool with automatic retry logic."""
        server = self.client.get_server(server_name)
        
        for attempt in range(self.retry_config["max_retries"]):
            try:
                result = await asyncio.wait_for(
                    server.call_tool(tool_name, arguments),
                    timeout=self.retry_config["timeout"]
                )
                return result
                
            except asyncio.TimeoutError:
                if attempt == self.retry_config["max_retries"] - 1:
                    raise MCPError("Tool execution timed out after retries")
                await asyncio.sleep(self.retry_config["backoff_factor"] ** attempt)
                
            except MCPError as e:
                if e.code == "server_unavailable" and attempt < self.retry_config["max_retries"] - 1:
                    # Try to reconnect
                    await self.reconnect_server(server_name)
                    await asyncio.sleep(self.retry_config["backoff_factor"] ** attempt)
                else:
                    raise
```

## Client Configuration

### Configuration Management

```python
class ClientConfig:
    def __init__(self, config_file: str):
        with open(config_file, 'r') as f:
            self.config = json.load(f)
    
    def get_servers(self):
        """Get server configurations."""
        return self.config.get("servers", [])
    
    def get_client_settings(self):
        """Get client-specific settings."""
        return self.config.get("client", {})
    
    def get_security_settings(self):
        """Get security-related settings."""
        return self.config.get("security", {})

# Example configuration file
config = {
    "client": {
        "name": "my-assistant",
        "version": "1.0.0",
        "timeout": 30,
        "max_concurrent_requests": 10
    },
    "servers": [
        {
            "name": "filesystem",
            "transport": "stdio",
            "command": ["python", "/path/to/fs_server.py"],
            "allowed_paths": ["/home/user/documents"],
            "timeout": 15
        },
        {
            "name": "api-gateway",
            "transport": "https",
            "url": "https://api.example.com/mcp",
            "auth": {
                "type": "bearer",
                "token_env": "API_GATEWAY_TOKEN"
            }
        }
    ],
    "security": {
        "allowed_hosts": ["api.example.com"],
        "verify_ssl": True,
        "max_tool_execution_time": 60
    }
}
```

## Performance Considerations

### Connection Pooling

```python
class ConnectionPool:
    def __init__(self, max_connections: int = 10):
        self.max_connections = max_connections
        self.connections = {}
        self.semaphore = asyncio.Semaphore(max_connections)
    
    async def get_connection(self, server_name: str):
        """Get a connection from the pool."""
        async with self.semaphore:
            if server_name not in self.connections:
                self.connections[server_name] = await self.create_connection(server_name)
            return self.connections[server_name]
```

### Caching Strategies

```python
class CachingClient:
    def __init__(self):
        self.resource_cache = {}
        self.cache_ttl = 300  # 5 minutes
    
    async def read_resource_cached(self, server_name: str, resource_uri: str):
        """Read resource with caching."""
        cache_key = f"{server_name}:{resource_uri}"
        
        if cache_key in self.resource_cache:
            cached_data, timestamp = self.resource_cache[cache_key]
            if time.time() - timestamp < self.cache_ttl:
                return cached_data
        
        # Fetch fresh data
        data = await self.read_resource(server_name, resource_uri)
        self.resource_cache[cache_key] = (data, time.time())
        return data
```

## Security Best Practices

### Permission Management

```python
class SecureClient:
    def __init__(self):
        self.permissions = {}
        self.audit_log = []
    
    def check_permission(self, server_name: str, operation: str, resource: str = None):
        """Check if operation is permitted."""
        server_perms = self.permissions.get(server_name, {})
        
        if operation not in server_perms.get("allowed_operations", []):
            raise PermissionError(f"Operation {operation} not allowed for {server_name}")
        
        if resource and not self.is_resource_allowed(server_name, resource):
            raise PermissionError(f"Access to {resource} not allowed")
    
    async def call_tool_secure(self, server_name: str, tool_name: str, arguments: dict):
        """Call tool with security checks."""
        self.check_permission(server_name, "tool_execution")
        
        # Log the operation
        self.audit_log.append({
            "timestamp": datetime.utcnow(),
            "server": server_name,
            "operation": "tool_execution",
            "tool": tool_name,
            "arguments": arguments
        })
        
        return await self.call_tool(server_name, tool_name, arguments)
```

## Testing Client Integration

### Mock Server for Testing

```python
class MockMCPServer:
    def __init__(self, name: str):
        self.name = name
        self.tools = {}
        self.resources = {}
    
    def add_tool(self, name: str, handler):
        self.tools[name] = handler
    
    async def call_tool(self, name: str, arguments: dict):
        if name not in self.tools:
            raise MCPError(f"Unknown tool: {name}")
        return await self.tools[name](arguments)

# Test example
async def test_client_workflow():
    # Create mock server
    mock_server = MockMCPServer("test-server")
    mock_server.add_tool("calculate", lambda args: {"result": args["a"] + args["b"]})
    
    # Test client
    client = MCPClient("test-client")
    client.add_server(mock_server)
    
    result = await client.call_tool("test-server", "calculate", {"a": 5, "b": 3})
    assert result["result"] == 8
```

## Best Practices

### 1. **Error Handling**
- Implement comprehensive error handling
- Use appropriate retry strategies
- Provide meaningful error messages to users

### 2. **Resource Management**
- Properly close connections
- Implement connection pooling for efficiency
- Clean up resources on shutdown

### 3. **Security**
- Validate all inputs from servers
- Implement permission checks
- Maintain audit logs for security-sensitive operations

### 4. **Performance**
- Use asynchronous operations where possible
- Implement appropriate caching strategies
- Monitor and optimize connection usage

### 5. **User Experience**
- Provide clear feedback during long operations
- Handle partial failures gracefully
- Offer fallback options when servers are unavailable

## Next Steps

After mastering client concepts:

- Explore [Core Server Concepts](/docs/learn/server-concepts) to understand the other side
- Learn about [Message Protocol](/docs/learn/message-protocol) for deeper integration
- Check out [Client Integration Patterns](/docs/learn/client-patterns) for advanced techniques