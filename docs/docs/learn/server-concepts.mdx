# Core Server Concepts

Understanding MCP server concepts is essential for building robust and secure servers that provide valuable capabilities to AI assistants. This guide covers the fundamental concepts, patterns, and best practices for MCP server development.

## Server Responsibilities

MCP servers act as capability providers that:

- **Expose tools** that clients can execute
- **Provide resources** that clients can access
- **Offer prompts** for specific use cases
- **Handle authentication** and authorization
- **Manage state** and persistence as needed
- **Implement security** and access controls

## Server Lifecycle

### 1. Initialization

```python
# Example server initialization
server = MCPServer("weather-server", "1.0.0")

@server.initialize()
async def initialize():
    """Server initialization logic."""
    # Load configuration
    config = load_config()
    
    # Initialize external connections
    await setup_database_connection()
    await setup_api_clients()
    
    # Register capabilities
    server.capabilities = {
        "tools": {},
        "resources": {},
        "prompts": {}
    }
```

### 2. Capability Registration

```python
# Register tools
@server.list_tools()
async def list_tools():
    return [
        Tool(
            name="get_weather",
            description="Get current weather for a city",
            inputSchema={
                "type": "object",
                "properties": {
                    "city": {"type": "string"},
                    "units": {"type": "string", "enum": ["metric", "imperial"]}
                },
                "required": ["city"]
            }
        )
    ]

# Register resources
@server.list_resources()
async def list_resources():
    return [
        Resource(
            uri="weather://current",
            name="Current Weather Data",
            description="Real-time weather information",
            mimeType="application/json"
        )
    ]
```

### 3. Request Handling

```python
@server.call_tool()
async def call_tool(name: str, arguments: dict):
    """Handle tool execution requests."""
    if name == "get_weather":
        return await handle_weather_request(arguments)
    else:
        raise MCPError(f"Unknown tool: {name}")

@server.read_resource()
async def read_resource(uri: str):
    """Handle resource access requests."""
    if uri.startswith("weather://"):
        return await handle_weather_resource(uri)
    else:
        raise MCPError(f"Unknown resource: {uri}")
```

## Core Server Capabilities

### Tools

Tools are executable functions that perform actions:

```python
class WeatherTool:
    def __init__(self, api_client):
        self.api_client = api_client
    
    async def get_weather(self, city: str, units: str = "metric"):
        """Get weather data for a city."""
        try:
            # Validate input
            if not city or len(city.strip()) == 0:
                raise ValueError("City name cannot be empty")
            
            # Call external API
            weather_data = await self.api_client.get_weather(city, units)
            
            # Format response
            return {
                "city": weather_data["name"],
                "temperature": weather_data["main"]["temp"],
                "description": weather_data["weather"][0]["description"],
                "humidity": weather_data["main"]["humidity"]
            }
        except Exception as e:
            raise MCPError(f"Failed to get weather: {str(e)}")
    
    def get_schema(self):
        """Return tool schema for registration."""
        return {
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The city name"
                },
                "units": {
                    "type": "string",
                    "enum": ["metric", "imperial"],
                    "description": "Temperature units",
                    "default": "metric"
                }
            },
            "required": ["city"]
        }
```

### Resources

Resources provide access to data and content:

```python
class FileSystemResource:
    def __init__(self, base_path: str):
        self.base_path = Path(base_path)
        self.allowed_extensions = {".txt", ".md", ".json", ".csv"}
    
    async def list_resources(self):
        """List available file resources."""
        resources = []
        for file_path in self.base_path.rglob("*"):
            if file_path.is_file() and file_path.suffix in self.allowed_extensions:
                rel_path = file_path.relative_to(self.base_path)
                resources.append(Resource(
                    uri=f"file://{rel_path}",
                    name=file_path.name,
                    description=f"File: {rel_path}",
                    mimeType=self.get_mime_type(file_path.suffix)
                ))
        return resources
    
    async def read_resource(self, uri: str):
        """Read a specific file resource."""
        if not uri.startswith("file://"):
            raise MCPError("Invalid file URI")
        
        file_path = self.base_path / uri[7:]  # Remove "file://" prefix
        
        # Security check
        if not self.is_path_allowed(file_path):
            raise MCPError("Access denied to file")
        
        try:
            content = file_path.read_text(encoding='utf-8')
            return ResourceContent(
                uri=uri,
                mimeType=self.get_mime_type(file_path.suffix),
                text=content
            )
        except Exception as e:
            raise MCPError(f"Failed to read file: {str(e)}")
    
    def is_path_allowed(self, path: Path) -> bool:
        """Check if path access is allowed."""
        try:
            resolved_path = path.resolve()
            return (
                resolved_path.is_relative_to(self.base_path.resolve()) and
                resolved_path.suffix in self.allowed_extensions
            )
        except:
            return False
```

### Prompts

Prompts provide template-based interactions:

```python
class CodeReviewPrompt:
    def __init__(self):
        self.templates = {
            "python": self.python_review_template,
            "javascript": self.javascript_review_template,
            "general": self.general_review_template
        }
    
    async def get_prompt(self, name: str, arguments: dict):
        """Generate a code review prompt."""
        if name != "code_review":
            raise MCPError(f"Unknown prompt: {name}")
        
        language = arguments.get("language", "general")
        code = arguments.get("code", "")
        
        if not code:
            raise MCPError("Code argument is required")
        
        template = self.templates.get(language, self.templates["general"])
        
        return PromptMessage(
            role="user",
            content=template.format(
                code=code,
                language=language,
                **arguments
            )
        )
    
    def python_review_template(self):
        return """Please review this Python code for:
1. Code quality and style (PEP 8)
2. Potential bugs or issues
3. Performance considerations
4. Security concerns

Code to review:
```python
{code}
```

Additional context: {context}
"""
```

## Advanced Server Patterns

### State Management

```python
class StatefulServer:
    def __init__(self):
        self.sessions = {}
        self.server_state = {}
    
    async def create_session(self, client_id: str):
        """Create a new client session."""
        session_id = str(uuid.uuid4())
        self.sessions[session_id] = {
            "client_id": client_id,
            "created_at": datetime.utcnow(),
            "state": {}
        }
        return session_id
    
    async def get_session_state(self, session_id: str):
        """Get session-specific state."""
        if session_id not in self.sessions:
            raise MCPError("Invalid session ID")
        return self.sessions[session_id]["state"]
    
    async def update_session_state(self, session_id: str, key: str, value):
        """Update session state."""
        session = self.sessions.get(session_id)
        if not session:
            raise MCPError("Invalid session ID")
        session["state"][key] = value
```

### Authentication and Authorization

```python
class SecureServer:
    def __init__(self):
        self.auth_tokens = {}
        self.permissions = {}
    
    def authenticate(self, token: str) -> str:
        """Authenticate client and return user ID."""
        user_id = self.auth_tokens.get(token)
        if not user_id:
            raise MCPError("Invalid authentication token")
        return user_id
    
    def authorize(self, user_id: str, resource: str, action: str) -> bool:
        """Check if user is authorized for action on resource."""
        user_perms = self.permissions.get(user_id, {})
        resource_perms = user_perms.get(resource, [])
        return action in resource_perms
    
    async def secure_call_tool(self, token: str, tool_name: str, arguments: dict):
        """Call tool with authentication and authorization."""
        # Authenticate
        user_id = self.authenticate(token)
        
        # Authorize
        if not self.authorize(user_id, f"tool:{tool_name}", "execute"):
            raise MCPError("Insufficient permissions")
        
        # Execute tool
        return await self.call_tool(tool_name, arguments)
```

### Error Handling and Validation

```python
from pydantic import BaseModel, ValidationError
from typing import Optional

class WeatherRequest(BaseModel):
    city: str
    units: Optional[str] = "metric"
    include_forecast: Optional[bool] = False

class ValidatingServer:
    async def call_tool(self, name: str, arguments: dict):
        """Call tool with input validation."""
        try:
            if name == "get_weather":
                # Validate input using Pydantic
                request = WeatherRequest(**arguments)
                return await self.get_weather(request)
            else:
                raise MCPError(f"Unknown tool: {name}")
                
        except ValidationError as e:
            raise MCPError(f"Invalid arguments: {e}")
        except Exception as e:
            # Log error for debugging
            logger.error(f"Tool execution failed: {e}")
            raise MCPError("Internal server error")
    
    async def get_weather(self, request: WeatherRequest):
        """Get weather with validated input."""
        # Implementation with guaranteed valid input
        pass
```

### Resource Caching

```python
import asyncio
from datetime import datetime, timedelta

class CachingServer:
    def __init__(self):
        self.cache = {}
        self.cache_ttl = timedelta(minutes=5)
    
    async def read_resource_cached(self, uri: str):
        """Read resource with caching."""
        cache_key = f"resource:{uri}"
        
        # Check cache
        if cache_key in self.cache:
            cached_data, timestamp = self.cache[cache_key]
            if datetime.utcnow() - timestamp < self.cache_ttl:
                return cached_data
        
        # Fetch fresh data
        data = await self.read_resource_uncached(uri)
        
        # Cache the result
        self.cache[cache_key] = (data, datetime.utcnow())
        
        return data
    
    async def invalidate_cache(self, pattern: str = None):
        """Invalidate cache entries."""
        if pattern:
            keys_to_remove = [k for k in self.cache.keys() if pattern in k]
            for key in keys_to_remove:
                del self.cache[key]
        else:
            self.cache.clear()
```

## Performance Optimization

### Asynchronous Operations

```python
class AsyncServer:
    def __init__(self):
        self.http_client = aiohttp.ClientSession()
        self.db_pool = None
    
    async def initialize(self):
        """Initialize async resources."""
        self.db_pool = await asyncpg.create_pool(
            "postgresql://user:pass@localhost/db"
        )
    
    async def call_tool_async(self, name: str, arguments: dict):
        """Handle multiple async operations."""
        if name == "aggregate_data":
            # Execute multiple async operations concurrently
            tasks = [
                self.fetch_api_data(arguments["source1"]),
                self.fetch_db_data(arguments["query"]),
                self.process_file(arguments["file_path"])
            ]
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Handle any exceptions
            processed_results = []
            for result in results:
                if isinstance(result, Exception):
                    logger.error(f"Operation failed: {result}")
                    processed_results.append(None)
                else:
                    processed_results.append(result)
            
            return {"results": processed_results}
```

### Connection Pooling

```python
class PooledServer:
    def __init__(self):
        self.db_pool = None
        self.http_session = None
    
    async def setup_pools(self):
        """Set up connection pools."""
        # Database pool
        self.db_pool = await asyncpg.create_pool(
            database_url,
            min_size=5,
            max_size=20,
            command_timeout=30
        )
        
        # HTTP session with connection pooling
        connector = aiohttp.TCPConnector(
            limit=100,
            limit_per_host=10,
            ttl_dns_cache=300
        )
        self.http_session = aiohttp.ClientSession(connector=connector)
    
    async def execute_db_query(self, query: str, *args):
        """Execute database query using pool."""
        async with self.db_pool.acquire() as connection:
            return await connection.fetch(query, *args)
```

## Security Best Practices

### Input Sanitization

```python
import re
from pathlib import Path

class SecureFileServer:
    def __init__(self, base_path: str):
        self.base_path = Path(base_path).resolve()
        self.allowed_patterns = [
            re.compile(r'^[a-zA-Z0-9_\-\.]+$'),  # Alphanumeric, underscore, dash, dot
        ]
    
    def sanitize_path(self, path: str) -> Path:
        """Sanitize and validate file path."""
        # Remove any path traversal attempts
        clean_path = path.replace('..', '').replace('//', '/')
        
        # Validate pattern
        if not any(pattern.match(clean_path) for pattern in self.allowed_patterns):
            raise MCPError("Invalid path format")
        
        # Resolve and check if within base directory
        full_path = (self.base_path / clean_path).resolve()
        if not full_path.is_relative_to(self.base_path):
            raise MCPError("Path outside allowed directory")
        
        return full_path
```

### Rate Limiting

```python
import time
from collections import defaultdict

class RateLimitedServer:
    def __init__(self):
        self.request_counts = defaultdict(list)
        self.rate_limit = 60  # requests per minute
        self.window_size = 60  # seconds
    
    def check_rate_limit(self, client_id: str) -> bool:
        """Check if client is within rate limits."""
        now = time.time()
        
        # Clean old requests
        self.request_counts[client_id] = [
            req_time for req_time in self.request_counts[client_id]
            if now - req_time < self.window_size
        ]
        
        # Check if under limit
        if len(self.request_counts[client_id]) >= self.rate_limit:
            return False
        
        # Record this request
        self.request_counts[client_id].append(now)
        return True
    
    async def call_tool_rate_limited(self, client_id: str, tool_name: str, arguments: dict):
        """Call tool with rate limiting."""
        if not self.check_rate_limit(client_id):
            raise MCPError("Rate limit exceeded")
        
        return await self.call_tool(tool_name, arguments)
```

## Testing Server Implementation

### Unit Testing

```python
import pytest
from unittest.mock import AsyncMock

class TestWeatherServer:
    @pytest.fixture
    async def server(self):
        server = WeatherServer()
        server.api_client = AsyncMock()
        return server
    
    async def test_get_weather_success(self, server):
        # Mock API response
        server.api_client.get_weather.return_value = {
            "name": "San Francisco",
            "main": {"temp": 20, "humidity": 60},
            "weather": [{"description": "sunny"}]
        }
        
        result = await server.call_tool("get_weather", {"city": "San Francisco"})
        
        assert result["city"] == "San Francisco"
        assert result["temperature"] == 20
        assert result["description"] == "sunny"
    
    async def test_get_weather_invalid_city(self, server):
        with pytest.raises(MCPError) as exc_info:
            await server.call_tool("get_weather", {"city": ""})
        
        assert "City name cannot be empty" in str(exc_info.value)
```

### Integration Testing

```python
async def test_server_integration():
    """Test server with real MCP client."""
    # Start server
    server = WeatherServer()
    transport = TestTransport()
    
    # Connect client
    client = MCPClient()
    await client.connect(transport)
    
    # Test tool execution
    result = await client.call_tool("get_weather", {"city": "London"})
    assert "temperature" in result
    
    # Test resource access
    resources = await client.list_resources()
    assert len(resources) > 0
```

## Best Practices

### 1. **Security First**
- Validate all inputs thoroughly
- Implement proper authentication and authorization
- Use secure defaults and fail safely

### 2. **Error Handling**
- Provide clear, actionable error messages
- Log errors appropriately for debugging
- Never expose internal system details

### 3. **Performance**
- Use async/await for I/O operations
- Implement appropriate caching strategies
- Monitor resource usage and optimize

### 4. **Reliability**
- Handle failures gracefully
- Implement retry logic where appropriate
- Provide health check endpoints

### 5. **Maintainability**
- Use clear, descriptive schemas
- Document your APIs thoroughly
- Structure code for easy testing and modification

## Next Steps

After mastering server concepts:

- Explore [Security Model](/docs/learn/security) for production deployments
- Learn [Server Patterns](/docs/learn/server-patterns) for advanced architectures
- Check out [How-to Guides](/docs/how-to-guides) for specific implementation scenarios